#!/usr/bin/env python

import io
import json
import os.path
import sys
import time
import paho.mqtt.client as mqtt
import paho.mqtt.publish as publish
from argparse import ArgumentParser


# ----------------------------------------------------------------------
# MQTT publishing
# ----------------------------------------------------------------------

def send_discovery_config(config):
    """Unregister and reregister with Home Assistant, to get a fresh
       autodiscovery configuration in there."""
    send_payload("config", "", config)
    send_payload("config", json.dumps({
        "unique_id": config["unique_id"],
        "name": config["name"],
        "state_topic": "%s/state" % config["base_topic"],
        "command_topic": "%s/set" % config["base_topic"],
        "json_attributes_topic": "%s/attributes" % config["base_topic"],
        "optimistic": "false",
        "retain": "true",
        "icon": "mdi:shape-rectangle-plus",
        "device": {
            "identifiers": [config["unique_id"]],
            "manufacturer": "Maurice Makaay",
            "model": "Raspberry Ambilite",
            "sw_version": config["version"],
            "name": "Ambilite"
        }
    }), config)

def send_attributes(state, config):
    send_payload("attributes", json.dumps(state["attributes"]), config)

def send_state(state, config):
    send_payload("state", "ON" if state["enabled"] else "OFF", config)

def send_tv_image(img, config):
    buf = io.BytesIO()
    img.save(buf, format="JPEG")
    send_payload("tv_image", buf.getvalue(), config, False)
 
def send_payload(topic, payload, config, log_payload=True):
    if log_payload:
        verbose("Publish: %s: %s" % (topic, payload))
    else:
        verbose("Publish: %s" % topic)

    publish.single(
        "%s/%s" % (config["base_topic"], topic), payload,
        hostname=config["broker"],
        auth = {
            "username": config["username"],
            "password": config["password"]
        })


# ----------------------------------------------------------------------
# MQTT subscription
# ----------------------------------------------------------------------

def start_subscription_loop(state, config): 
    """Create an MQTT subscriber to handle incoming messages and
       start a listen loop in a separate thread to handle these
       messages."""
    client = mqtt.Client(config["unique_id"])
    client.config = config
    client.state = state
    client.username_pw_set(
        username=config["username"],
        password=config["password"])
    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_message = on_message
    client.connect(config["broker"])
    client.subscribe("%s/set" % config["base_topic"], qos=0)
    client.loop_start()

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Subscriber: Connected to broker")
        send_discovery_config(client.config)
        send_state(client.state, client.config)
    else:
        print("Subscriber: Connecting to broker failed (rc = %d)" % rc)

def on_disconnect(client, userdata, rc):
    if rc == 0:
        print("Subscriber: Disconnected from broker")
    else:
        print("Subscriber: Unexpected disconnected from broker (rc = %d)" % rc)

def on_message(client, userdata, message):
    verbose("Subscriber: Incoming message: %s" % message.topic)
    on_or_off = str(message.payload.decode("utf-8"))
    try:
        if on_or_off == 'ON':
            client.state["enabled"] = True
            fh = open(client.config["state_file"], "w")
            fh.write("Ambilite turned on at %f" % time.time())
            fh.close()
            print("Subscriber: Ambilite turned on")
        else:
            client.state["enabled"] = False
            if os.path.exists(client.config["state_file"]):
                os.unlink(client.config["state_file"])
            print("Subscriber: Ambilite turned off")

            off_img = Image.new('RGB', (492, 320), 'grey')
            font = ImageFont.truetype("/usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf", 20)
            ImageDraw.Draw(off_img).text((145, 120), '-- uitgeschakeld --', fill='white', font=font)
            send_tv_image(off_img, config)

        send_state(client.state, client.config)
    except Exception as e:
        print("Subscriber: Failed to set ambilite state: %s: %s" % (type(e).__name__, str(e)))


# ----------------------------------------------------------------------
# MQTT publishing
# ----------------------------------------------------------------------

import numpy as np
import numexpr as ne
import picamera
import picamera.array
import rgbxy
from PIL import Image, ImageDraw, ImageFont


def start_publish_loop(state, config):
    with picamera.PiCamera() as cam:
        while True:
            if state["enabled"]:
                try:
                    handle_ambilite(cam, config)
                    #handle_itv_led(cam)
                except Exception as e:
                    verbose("Publish: Unhandled exception: %s" % str(e))
            else:
                verbose("Publish: No action, ambilite is disabled")
                time.sleep(1)


def handle_itv_led(state, config):
    cam.zoom = (0.50, 0.58, 0.10, 0.10)
    cam.resolution = (736, 480)
    cam.awb_mode = 'fluorescent'
    cam.meter_mode = 'average'
    cam.saturation = 100
    cam.contrast = 100

    with picamera.array.PiRGBArray(cam) as store:
        cam.capture(store, format="bgr")
        img = store.array
        #cv2.imwrite('/var/www/html/still_itv_ps4.swap.jpg', img)
        #os.rename('/var/www/html/still_itv_ps4.swap.jpg', '/var/www/html/still_itv_ps4.jpg')

def handle_ambilite(cam, config):
    """Take a shot of the tv screen, compute the dominant color and
       pushlish the color to Home Assistant."""
    cam.zoom = (0.48, 0.20, 0.305, 0.255)
    cam.resolution = (736, 480)
    cam.awb_mode = 'fluorescent'
    cam.meter_mode = 'backlit'
    cam.saturation = 0
    cam.contrast = 0

    with picamera.array.PiRGBArray(cam) as store:
        cam.capture(store, format="bgr")  
        img = store.array

        #cv2.imwrite('/var/www/html/still_tv.swap.jpg', img)
        #os.rename('/var/www/html/still_tv.swap.jpg', '/var/www/html/still_tv.jpg')
        img = img[:, :, ::-1]
        dominant_color = get_dominant_color(img)

    #file = open('/var/www/html/index.html', 'w')
    #color_style = "rgb(%d,%d,%d)" % dominant_color
    #file.write("<!DOCTYPE HTML>\n")
    #file.write("<body style=\"background-color: %s\">" % color_style)
    #file.write("<img style=\"float:left\" src=\"still_tv.jpg\">\n")
    #file.write("<img style=\"float:left\" src=\"still_itv_ps4.jpg\">\n")
    #file.write("</body>")
    #file.close()

    #colors = {
    #    "left": dominant_color,
    #    "right": dominant_color,
    #    "top": dominant_color,
    #}

    #file = open('/var/www/html/still_tv_colors.swap.json', 'w')
    #file.write(json.dumps(colors))
    #file.close()
    #os.rename(
    #    '/var/www/html/still_tv_colors.swap.json',
    #    '/var/www/html/still_tv_colors.json')
    #print(repr(colors))

    set_color_in_state(dominant_color, config, state)
    send_attributes(state, config)
    send_state(state, config)
    send_tv_image(Image.fromarray(img), config)

def get_dominant_color(img):
    SAMPLE_STEP = 15
    POSTERIZE = 25
    LOW = 50
    HIGH = 220
    TOP_SCREEN_CUTOFF = 0.7

    # To save time in the following steps, take a sample of the
    # total amount of items. For our case (determining the dominant
    # color for an ambilight-like setup, this is good enough).
    #
    # The bottom of the screen normally is not that interesting for
    # the single color ambilight setup that I'm going for, so
    # that's why I go for a top section only here.
    height = int(img.shape[0] * TOP_SCREEN_CUTOFF)
    downsampled = img[0:height:SAMPLE_STEP, 0::SAMPLE_STEP]

    # Create a copy to reduce colors further, so we can later on
    # come back to the downsampled image.
    reduced = downsampled.copy()

    # Pull all items that are too dark or too light to (0, 0, 0).
    #extremes = (reduced < LOW) & (reduced > HIGH)
    #extremes = 0
    reduced[np.all(reduced < LOW, axis=-1)] = 0
    reduced[np.all(reduced > HIGH, axis=-1)] = 0

    # Reduce the number of colors in the image, by grouping them
    # in bins. When we have a lot of slightly different colors in the image,
    # this will group those colors into a single group, making all of the
    # colors count for finding a good dominant color.
    reduced = reduced // POSTERIZE * POSTERIZE

    # Pull all items that are now too dark or too light to (0, 0, 0).
    reduced[np.all(reduced < LOW, axis=-1)] = 0
    reduced[np.all(reduced > HIGH, axis=-1)] = 0

    # Find the dominant color bin that is not (0, 0, 0)..
    # For this, first convert the x, y, (r, g, b) dimensions into a
    # list of (r, g, b) items.
    flat = reduced.reshape(-1, 3)

    # Filter out the items that are (0, 0, 0).
    flat = flat[np.all(flat != (0, 0, 0), -1)]

    # No items left?
    if not len(flat):
        return (0, 0, 0)

    # Convert the (r, g, b) values into a single integer value.
    col_range = (256, 256, 256)
    eval_params = {
        'R': flat[:,0],
        'G': flat[:,1],
        'B': flat[:,2],
        'Rmax': col_range[0],
        'Gmax': col_range[1]
    }
    rgb_values = ne.evaluate('R*Rmax*Gmax + G*Gmax + B', eval_params)

    # Find the dominant RGB integer value.
    dominant = np.bincount(rgb_values).argmax()

    # Reverse engineer this value into an (r, g, b) array.
    bin_rgb = np.unravel_index(dominant, col_range)

    # Find the original image colors that fall in this bin.
    use = downsampled[np.all(reduced == bin_rgb, 2)]

    # Compute the average color from the original colors.
    average_rgb = tuple(int(d) for d in np.average(use, 0))

    return average_rgb

def set_color_in_state(color, config, state):
    state["attributes"]["r"] = color[0]
    state["attributes"]["g"] = color[1]
    state["attributes"]["b"] = color[2]
    for name, converter in config["color_converters"].items():
        xy = converter.rgb_to_xy(*color)
        state["attributes"]["%s_x" % name] = xy[0]
        state["attributes"]["%s_y" % name] = xy[1]


# ----------------------------------------------------------------------
# Main
# ----------------------------------------------------------------------

# I know, my home automation MQTT password  can be found in this file.
# No worries. It's my dev host and it is not accessible from the internet.
# This will be moved to a configuration file for the final version.

config = {
    "version": "1.0.0",
    "broker": "172.17.206.1",
    "username": "hass",
    "password": "burgers",
    "state_file": "/var/run/ambilite.active",
    "base_topic": "homeassistant/switch/ambilite",
    "unique_id": "ambilite-mediacontroller",
    "name": "ambilite",
    "color_converters": {
        "gamutA": rgbxy.Converter(rgbxy.GamutA),
        "gamutB": rgbxy.Converter(rgbxy.GamutB),
        "gamutC": rgbxy.Converter(rgbxy.GamutC)
    }
}

state = {
    "enabled": os.path.exists(config["state_file"]),
    "attributes": {}
}

p = ArgumentParser(description="Look at the tv")
p.add_argument(
    "-v", "--verbose",
    default=False, action="store_true",
    help="enable verbose output (default: disabled)")
args = p.parse_args()

if args.verbose:
    def verbose(msg):
        print(msg)
else:
    def verbose(msg):
        pass

set_color_in_state((100, 100, 100), config, state)
start_subscription_loop(state, config)
start_publish_loop(state, config)

